<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Green Cube with Rotated Text</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  75, window.innerWidth/window.innerHeight, 0.1, 1000
);
camera.position.z = 3;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff,1.5));
const directionalLight = new THREE.DirectionalLight(0xffffff,1);
directionalLight.position.set(5,5,5);
scene.add(directionalLight);

// Create face textures using rotated text
function createFaceTexture(happy = true){
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');

  // Green background
  ctx.fillStyle = '#00ff00';
  ctx.fillRect(0,0,256,256);

  // Rotate text 90 deg
  ctx.translate(128,128);
  ctx.rotate(- Math.PI / 3); // 90 degrees
  ctx.fillStyle = '#000';
  ctx.font = 'bold 150px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(happy ? '(:' : '):', 0, 0);

  return new THREE.CanvasTexture(canvas);
}

const happyTexture = createFaceTexture(true);
const sadTexture = createFaceTexture(false);

// Cube materials: front textured, others green
const greenMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
const materials = [
  greenMaterial, greenMaterial, greenMaterial, greenMaterial,
  new THREE.MeshStandardMaterial({ map: happyTexture }), greenMaterial
];

const geometry = new THREE.BoxGeometry();
const cube = new THREE.Mesh(geometry, materials);
scene.add(cube);

// Track mouse
let mouseX=0, mouseY=0;
let mouseVisible=true;
document.addEventListener("mousemove",(e)=>{
  mouseX=(e.clientX/window.innerWidth)*2-1;
  mouseY=(e.clientY/window.innerHeight)*2-1;
  mouseVisible=true;
});
document.addEventListener("mouseleave",()=>{mouseVisible=false;});
document.addEventListener("mouseout",()=>{mouseVisible=false;});

// Resize
window.addEventListener("resize",()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Animate
function animate(){
  requestAnimationFrame(animate);

  const targetX = (mouseVisible ? mouseY : 0) * Math.PI * 0.25;
  const targetY = (mouseVisible ? mouseX : 0) * Math.PI * 0.25;

  cube.rotation.x += (targetX - cube.rotation.x) * 0.15;
  cube.rotation.y += (targetY - cube.rotation.y) * 0.15;

  // Update face depending on mouse visibility
  cube.material[4].map = mouseVisible ? happyTexture : sadTexture;
  cube.material[4].map.needsUpdate = true;

  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
