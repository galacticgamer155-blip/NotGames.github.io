<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Conway's Game of Life</title>
  <style>
    :root {
      --bg: #0f1218;
      --panel: #171b22;
      --ink: #e7ebf3;
      --muted: #9aa3b2;
      --accent: #6ee7ff;
      --alive: #a3e635; /* lime-400 */
      --grid: #2a2f39;
      --danger: #f87171; /* red-400 */
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 70% -10%, #13202b 0%, var(--bg) 40%);
      color: var(--ink);
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    header {
      padding: 16px 20px;
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px;
    }
    header h1 { font-size: 18px; font-weight: 650; margin: 0; letter-spacing: 0.3px; }

    .wrap {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 16px;
      padding: 0 16px 16px 16px;
    }

    @media (max-width: 900px) {
      .wrap { grid-template-columns: 1fr; }
      aside { order: 2; }
    }

    aside {
      background: var(--panel);
      border: 1px solid #222832;
      border-radius: 16px;
      padding: 14px;
      display: grid; gap: 12px;
      align-content: start;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .row label { font-size: 12px; color: var(--muted); }
    .hint { color: var(--muted); font-size: 12px; }

    button, select, input[type="number"], input[type="range"] {
      background: #0e1117;
      color: var(--ink);
      border: 1px solid #2a303c;
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 14px;
      outline: none;
    }
    button { cursor: pointer; transition: transform .05s ease, background .2s ease, border-color .2s ease; }
    button:hover { border-color: #3b4354; }
    button:active { transform: translateY(1px); }
    .primary { background: #0b1220; border-color: #2b3a55; }
    .accent { background: #0b141b; border-color: #1e2a33; box-shadow: inset 0 0 0 1px #183b42; }
    .danger { border-color: #3a2325; background: #1a0f10; }

    .toolbar { display: grid; gap: 8px; }
    .toolbar .row { justify-content: space-between; }

    canvas {
      width: 100%;
      height: 100%;
      background: #0b0f15;
      border: 1px solid #1a2230;
      border-radius: 16px;
      display: block;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    .board-wrap {
      position: relative;
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0) 30%);
      border-radius: 16px;
      overflow: hidden;
    }

    .status {
      display: flex; gap: 12px; align-items: center; flex-wrap: wrap;
      padding: 8px 0 0 0;
      font-size: 13px; color: var(--muted);
    }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: #0a0d12; border: 1px solid #222a35; padding: 1px 6px; border-radius: 6px; color: #c7d2fe; }
  </style>
</head>
<body>
  <header>
    <h1>Conway's Game of Life</h1>
    <div class="hint">Click to toggle cells • Drag to paint • <span class="kbd">Space</span> play/pause</div>
  </header>

  <div class="wrap">
    <aside>
      <div class="toolbar">
        <div class="row" style="gap: 8px; flex-wrap: nowrap;">
          <button id="playPause" class="primary" title="Space">Play</button>
          <button id="step" title="S">Step</button>
          <button id="clear" class="danger" title="C">Clear</button>
          <button id="random" class="accent" title="R">Random</button>
        </div>

        <div class="row">
          <label for="speed">Speed</label>
          <input id="speed" type="range" min="1" max="60" value="12" />
          <span id="speedLabel" class="hint">12 gen/s</span>
        </div>

        <div class="row">
          <label for="density">Random density</label>
          <input id="density" type="range" min="0" max="100" value="25" />
          <span id="densityLabel" class="hint">25%</span>
        </div>

        <div class="row" style="gap: 6px;">
          <label>Grid size</label>
          <input id="rows" type="number" min="10" max="400" value="60" style="width:92px;" />
          <span class="hint">×</span>
          <input id="cols" type="number" min="10" max="400" value="100" style="width:92px;" />
          <button id="applySize">Apply</button>
        </div>

        <div class="row">
          <label>
            <input id="wrap" type="checkbox" checked /> Wrap edges
          </label>
        </div>

        <div class="row">
          <label>
            <input id="showGrid" type="checkbox" checked /> Show grid
          </label>
        </div>

        <div class="status">
          <div>Gen: <strong id="gen">0</strong></div>
          <div>Alive: <strong id="alive">0</strong></div>
        </div>

        <div class="hint">Shortcuts: <span class="kbd">Space</span> play/pause • <span class="kbd">S</span> step • <span class="kbd">R</span> random • <span class="kbd">C</span> clear</div>
      </div>
    </aside>

    <main class="board-wrap">
      <canvas id="board"></canvas>
    </main>
  </div>

  <footer style="padding: 10px 16px 18px 16px;">
    <span class="hint">Conway's Game of Life — implemented with a single HTML file, no libraries. ©</span>
  </footer>

  <script>
    // ====== Utilities ======
    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

    // ====== State ======
    let rows = 60;
    let cols = 100;
    let gen = 0;
    let playing = false;
    let wrapEdges = true;
    let showGrid = true;

    let grid = new Uint8Array(rows * cols);
    let nextGrid = new Uint8Array(rows * cols);

    // Rendering
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    function resizeCanvasToContainer() {
      const main = canvas.parentElement;
      // Leave some room; use device pixel ratio for crispness
      const dpr = Math.max(window.devicePixelRatio || 1, 1);
      const rect = main.getBoundingClientRect();
      const pad = 0;
      const targetW = Math.max(300, Math.floor(rect.width - pad));
      // Fit height to keep cells square
      const cellSize = Math.floor(targetW / cols);
      const targetH = cellSize * rows;
      canvas.width = targetW * dpr;
      canvas.height = targetH * dpr;
      canvas.style.height = targetH + 'px';
      canvas.style.width = targetW + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }

    function idx(r, c) { return r * cols + c; }

    function countNeighbors(r, c) {
      let sum = 0;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          let rr = r + dr, cc = c + dc;
          if (wrapEdges) {
            if (rr < 0) rr = rows - 1; else if (rr >= rows) rr = 0;
            if (cc < 0) cc = cols - 1; else if (cc >= cols) cc = 0;
            sum += grid[idx(rr, cc)];
          } else {
            if (rr < 0 || rr >= rows || cc < 0 || cc >= cols) continue;
            sum += grid[idx(rr, cc)];
          }
        }
      }
      return sum;
    }

    function stepOnce() {
      let aliveCount = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const i = idx(r, c);
          const n = countNeighbors(r, c);
          const alive = grid[i] === 1;
          // Rules
          let next = 0;
          if (alive && (n === 2 || n === 3)) next = 1;
          else if (!alive && n === 3) next = 1;
          nextGrid[i] = next;
          if (next) aliveCount++;
        }
      }
      // Swap buffers
      [grid, nextGrid] = [nextGrid, grid];
      gen++;
      updateStatus(aliveCount);
      draw();
    }

    function updateStatus(aliveCount = null) {
      if (aliveCount === null) {
        aliveCount = grid.reduce((a, b) => a + b, 0);
      }
      document.getElementById('gen').textContent = gen;
      document.getElementById('alive').textContent = aliveCount;
    }

    function draw() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);

      const cellW = w / cols;
      const cellH = h / rows;

      // Fill alive cells
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--alive');
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (grid[idx(r, c)] === 1) {
            ctx.fillRect(Math.floor(c * cellW), Math.floor(r * cellH), Math.ceil(cellW), Math.ceil(cellH));
          }
        }
      }

      if (showGrid && cellW >= 6 && cellH >= 6) {
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let r = 0; r <= rows; r++) {
          const y = Math.floor(r * cellH) + 0.5;
          ctx.moveTo(0, y); ctx.lineTo(w, y);
        }
        for (let c = 0; c <= cols; c++) {
          const x = Math.floor(c * cellW) + 0.5;
          ctx.moveTo(x, 0); ctx.lineTo(x, h);
        }
        ctx.stroke();
      }
    }

    // ====== Interaction ======
    let isMouseDown = false;
    let paintValue = 1; // 1 = alive, 0 = dead

    function eventToCell(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const c = clamp(Math.floor((x / rect.width) * cols), 0, cols - 1);
      const r = clamp(Math.floor((y / rect.height) * rows), 0, rows - 1);
      return { r, c };
    }

    canvas.addEventListener('mousedown', (e) => {
      isMouseDown = true;
      const { r, c } = eventToCell(e);
      const i = idx(r, c);
      paintValue = grid[i] ? 0 : 1; // toggle starting cell; drag continues with same value
      grid[i] = paintValue;
      updateStatus();
      draw();
    });
    window.addEventListener('mouseup', () => { isMouseDown = false; });
    canvas.addEventListener('mouseleave', () => { isMouseDown = false; });
    canvas.addEventListener('mousemove', (e) => {
      if (!isMouseDown) return;
      const { r, c } = eventToCell(e);
      const i = idx(r, c);
      if (grid[i] !== paintValue) {
        grid[i] = paintValue;
        updateStatus();
        draw();
      }
    });

    // Buttons & controls
    const playBtn = document.getElementById('playPause');
    const stepBtn = document.getElementById('step');
    const clearBtn = document.getElementById('clear');
    const randomBtn = document.getElementById('random');
    const speed = document.getElementById('speed');
    const speedLabel = document.getElementById('speedLabel');
    const density = document.getElementById('density');
    const densityLabel = document.getElementById('densityLabel');
    const rowsInput = document.getElementById('rows');
    const colsInput = document.getElementById('cols');
    const applySize = document.getElementById('applySize');
    const wrapChk = document.getElementById('wrap');
    const gridChk = document.getElementById('showGrid');

    function updateSpeedLabel() {
      speedLabel.textContent = `${speed.value} gen/s`;
    }
    speed.addEventListener('input', updateSpeedLabel);
    updateSpeedLabel();

    density.addEventListener('input', () => {
      densityLabel.textContent = `${density.value}%`;
    });

    function togglePlay() {
      playing = !playing;
      playBtn.textContent = playing ? 'Pause' : 'Play';
    }

    playBtn.addEventListener('click', togglePlay);
    stepBtn.addEventListener('click', () => { if (!playing) stepOnce(); });
    clearBtn.addEventListener('click', () => {
      grid.fill(0); gen = 0; updateStatus(); draw();
    });
    randomBtn.addEventListener('click', () => {
      const pct = Number(density.value) / 100;
      let alive = 0;
      for (let i = 0; i < grid.length; i++) {
        const v = Math.random() < pct ? 1 : 0;
        grid[i] = v; alive += v;
      }
      gen = 0; updateStatus(alive); draw();
    });

    wrapChk.addEventListener('change', () => { wrapEdges = wrapChk.checked; });
    gridChk.addEventListener('change', () => { showGrid = gridChk.checked; draw(); });

    applySize.addEventListener('click', () => {
      const newR = clamp(parseInt(rowsInput.value, 10) || rows, 10, 400);
      const newC = clamp(parseInt(colsInput.value, 10) || cols, 10, 400);
      if (newR === rows && newC === cols) return;
      rows = newR; cols = newC;
      grid = new Uint8Array(rows * cols);
      nextGrid = new Uint8Array(rows * cols);
      gen = 0; updateStatus();
      resizeCanvasToContainer();
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
      else if (e.key.toLowerCase() === 's') { e.preventDefault(); if (!playing) stepOnce(); }
      else if (e.key.toLowerCase() === 'r') { e.preventDefault(); randomBtn.click(); }
      else if (e.key.toLowerCase() === 'c') { e.preventDefault(); clearBtn.click(); }
    });

    // ====== Main loop (timer based on gen/s) ======
    let lastTime = performance.now();
    let acc = 0; // accumulator in ms

    function loop(now) {
      const gensPerSec = Number(speed.value);
      const stepMs = 1000 / gensPerSec;
      const dt = now - lastTime; lastTime = now; acc += dt;

      if (playing) {
        while (acc >= stepMs) {
          stepOnce();
          acc -= stepMs;
        }
      } else {
        acc = 0; // reset accumulator when paused to make stepping snappy
      }

      requestAnimationFrame(loop);
    }

    // Initial layout & start
    function init() {
      rowsInput.value = rows; colsInput.value = cols;
      wrapChk.checked = wrapEdges; gridChk.checked = showGrid;
      resizeCanvasToContainer();
      updateStatus();
      requestAnimationFrame((t) => { lastTime = t; requestAnimationFrame(loop); });
    }

    window.addEventListener('resize', resizeCanvasToContainer);
    init();
  </script>
</body>
</html>
